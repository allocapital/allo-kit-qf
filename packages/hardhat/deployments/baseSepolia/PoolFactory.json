{
  "address": "0xf391B2abe96cac194f266c5ecD0197c1F3785C5f",
  "abi": [
    {
      "inputs": [],
      "name": "ERC1167FailedCreateClone",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "strategy",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "admins",
              "type": "address[]"
            },
            {
              "internalType": "address",
              "name": "allocationToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "distributionToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "maxAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint64[]",
              "name": "timestamps",
              "type": "uint64[]"
            },
            {
              "internalType": "string",
              "name": "metadataURI",
              "type": "string"
            }
          ],
          "indexed": false,
          "internalType": "struct PoolConfig",
          "name": "config",
          "type": "tuple"
        }
      ],
      "name": "Created",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "admins",
              "type": "address[]"
            },
            {
              "internalType": "address",
              "name": "allocationToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "distributionToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "maxAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint64[]",
              "name": "timestamps",
              "type": "uint64[]"
            },
            {
              "internalType": "string",
              "name": "metadataURI",
              "type": "string"
            }
          ],
          "internalType": "struct PoolConfig",
          "name": "config",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "deploy",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x0919a12eb510ae75ef878d00e3086317d281e44470715a835bdf950f933d1eb7",
  "receipt": {
    "to": null,
    "from": "0x8595e36857743A1C517e00179e6bA6D170DD1F51",
    "contractAddress": "0xf391B2abe96cac194f266c5ecD0197c1F3785C5f",
    "transactionIndex": 12,
    "gasUsed": "321239",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x563905ca06f7dd2b28fe46e414e5322a8c89a85a680324fc5085b75fd0a6ca24",
    "transactionHash": "0x0919a12eb510ae75ef878d00e3086317d281e44470715a835bdf950f933d1eb7",
    "logs": [],
    "blockNumber": 26626273,
    "cumulativeGasUsed": "2291639",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "68abb0f96633951c4834d81434b5b092",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ERC1167FailedCreateClone\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"admins\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"allocationToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributionToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64[]\",\"name\":\"timestamps\",\"type\":\"uint64[]\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct PoolConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"Created\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"admins\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"allocationToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributionToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64[]\",\"name\":\"timestamps\",\"type\":\"uint64[]\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"internalType\":\"struct PoolConfig\",\"name\":\"config\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ERC1167FailedCreateClone()\":[{\"details\":\"A clone instance deployment failed.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/PoolFactory.sol\":\"PoolFactory\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    /**\\n     * @dev A clone instance deployment failed.\\n     */\\n    error ERC1167FailedCreateClone();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xd18408af8a91bedb3d56343eeb9b30eb852e6dea93a5e2d5c6db9ca4cb905155\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"contracts/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nstruct PoolConfig {\\n    address owner;\\n    address[] admins;\\n    address allocationToken;\\n    address distributionToken;\\n    uint256 maxAmount;\\n    uint64[] timestamps;\\n    string metadataURI;\\n}\\n\\ninterface IPool {\\n    enum Status {\\n        pending,\\n        approved,\\n        rejected\\n    }\\n\\n    struct Registration {\\n        Status status;\\n        address owner;\\n        string metadataURI;\\n        bytes data; // Data can contain information that can be accessed later\\n    }\\n\\n    event Deployed(string name, address indexed owner, string schema, PoolConfig config);\\n    event Allocate(address indexed from, address indexed to, uint256 amount, address token, bytes data);\\n    event Register(address indexed project, address indexed owner, string metadataURI, bytes data);\\n    event Approve(address indexed project, address indexed approver, string metadataURI, bytes data);\\n    event Reject(address indexed project, address indexed rejecter, string metadataURI, bytes data);\\n    event Update(address indexed project, address indexed updater, string metadataURI, bytes data);\\n\\n\\n    function initialize(PoolConfig memory config, bytes memory data) external;\\n\\n    function _register(address project, string memory metadataURI, bytes memory data) external;\\n    function _update(address project, string memory metadataURI, bytes memory data) external;\\n    function _approve(address project, string memory metadataURI, bytes memory data) external;\\n    function _allocate(address[] memory recipients, uint256[] memory amounts, address token, bytes[] memory data)\\n        external;\\n    function _distribute(address[] memory recipients, uint256[] memory amounts, address token, bytes[] memory data)\\n        external;\\n}\\n\\n/*\\nTypes of Pools:\\nDirectGrants - pool manager transfer funds directly to projects\\nRetroFunding - selected voters vote on projects and pool gets distributed based on the votes\\nQuadraticFunding - people vote with money tokens and get matching funds from the pool based on quadratic formula\\nDedicatedDomainAllocation - selected panel of domain experts decide what projects receive matching funds\\nRFPs\\nBounties\\nCrowdfunding\\n*/\\ncontract Pool is IPool {\\n    bool private _initialized;\\n    PoolConfig public config;\\n\\n    mapping(address => Registration) public registrations;\\n\\n\\n    constructor(string memory _name, string memory _schema, PoolConfig memory _config) {\\n        // strategyName = _name;\\n        // schema = _schema;\\n        // metadataURI = _metadataURI;\\n        // id = keccak256(abi.encode(strategyName));\\n        emit Deployed(_name, msg.sender, _schema, _config);\\n    }\\n\\n\\n  function initialize(PoolConfig memory _config, bytes memory ) external virtual {\\n    require(!_initialized, \\\"Already initialized\\\");\\n    _initialized = true;\\n    config = _config;\\n  }\\n\\n    // MetadataURI contain details about project application\\n    function _register(address project, string memory _metadataURI, bytes memory data) public {\\n        require(registrations[project].owner == address(0), \\\"Already registered\\\");\\n        registrations[project] = Registration(Status.pending, msg.sender, _metadataURI, data);\\n        emit Register(project, msg.sender, _metadataURI, data);\\n    }\\n\\n    function _reject(address project, string memory _metadataURI, bytes memory data) public virtual {\\n        Registration storage registration = registrations[project];\\n        require(registration.status == Status.pending || registration.status == Status.approved, \\\"Already deregistered\\\");\\n        registration.status = Status.rejected;\\n        emit Reject(project, msg.sender, _metadataURI, data);\\n    }\\n\\n    // MetadataURI can contain Review information\\n    function _approve(address project, string memory _metadataURI, bytes memory data) public virtual {\\n        Registration storage registration = registrations[project];\\n        require(registration.status == Status.pending, \\\"Already approved or not registered yet\\\");\\n        registration.status = Status.approved;\\n        // MetadataURI here is Review information so we don't need to store it\\n        emit Approve(project, msg.sender, _metadataURI, data);\\n    }\\n\\n    function _update(address project, string memory _metadataURI, bytes memory data) public {\\n        require(registrations[project].status == Status.pending, \\\"Already approved or not registered yet\\\");\\n        require(registrations[project].owner == msg.sender, \\\"Must be owner to update\\\");\\n        registrations[project].metadataURI = _metadataURI;\\n        registrations[project].data = data;\\n        emit Update(project, msg.sender, _metadataURI, data);\\n    }\\n\\n    // Allocate tokens to recipients (transfers tokens from caller to recipients)\\n    // This can be used to transfer tokens to projects, or the contract itself to fund with matching funds for example\\n    function _allocate(address[] memory recipients, uint256[] memory amounts, address token, bytes[] memory data)\\n        public\\n        virtual\\n    {\\n        uint256 length = recipients.length;\\n        require(length > 0 && length == amounts.length, \\\"Mismatched lengths\\\");\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            bytes memory _data = i < data.length ? data[i] : bytes(\\\"\\\");\\n            require(recipients[i] != address(0), \\\"Recipient is zero address\\\");\\n            require(amounts[i] > 0, \\\"Amount is zero\\\");\\n            _beforeAllocate(recipients[i], amounts[i], token, _data);\\n            IERC20(token).transferFrom(msg.sender, recipients[i], amounts[i]);\\n            emit Allocate(msg.sender, recipients[i], amounts[i], token, _data);\\n        }\\n    }\\n\\n    // Distribute tokens to recipients (transfers tokens from the contract to recipients)\\n    // Can be used to distribute matching funds to projects\\n    function _distribute(address[] memory recipients, uint256[] memory amounts, address token, bytes[] memory data)\\n        public\\n        virtual\\n    {\\n        uint256 length = recipients.length;\\n        require(length > 0 && length == amounts.length, \\\"Mismatched lengths\\\");\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            bytes memory _data = i < data.length ? data[i] : bytes(\\\"\\\");\\n            require(recipients[i] != address(0), \\\"Recipient is zero address\\\");\\n            require(\\n                amounts[i] > 0 && amounts[i] <= IERC20(token).balanceOf(address(this)),\\n                \\\"Amount is zero or exceeds balance\\\"\\n            );\\n            _beforeDistribute(recipients[i], amounts[i], token, _data);\\n            IERC20(token).transfer(recipients[i], amounts[i]);\\n            emit Allocate(address(this), recipients[i], amounts[i], token, _data);\\n        }\\n    }\\n\\n    function _beforeAllocate(address recipient, uint256 amount, address token, bytes memory data) internal virtual {}\\n    function _beforeDistribute(address recipient, uint256 amount, address token, bytes memory data) internal virtual {}\\n}\\n\",\"keccak256\":\"0xe466d05ffdf3fcdafdde429322767a3f60a3890c07f6e7c8e5808fba90d44d81\",\"license\":\"MIT\"},\"contracts/PoolFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport {IPool, Pool, PoolConfig} from \\\"./Pool.sol\\\";\\n\\ncontract PoolFactory {\\n    event Created(address indexed strategy, address indexed pool, PoolConfig config);\\n\\n    function deploy(address implementation, PoolConfig calldata config, bytes calldata data) external returns (address) {\\n        // Pool pool = new Pool(config);\\n        // emit Created(implementation, address(pool), config);\\n        // return address(pool);\\n\\n        address poolAddress = Clones.clone(implementation);\\n        IPool(poolAddress).initialize(config, data);\\n        emit Created(implementation, poolAddress,  config);\\n        return poolAddress;\\n        /*\\n        Clone not supported by PolkaVM?\\n\\n        */\\n    }\\n}\\n\",\"keccak256\":\"0x0a57d1ba12bf926c1318b8c89fc22bf22e2f661098f7f521a6a4666f23695795\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506104d9806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80633938e38c14610030575b600080fd5b61004361003e3660046101ad565b61005f565b6040516001600160a01b03909116815260200160405180910390f35b60008061006b86610124565b60405163ab21f50760e01b81529091506001600160a01b0382169063ab21f5079061009e90889088908890600401610463565b600060405180830381600087803b1580156100b857600080fd5b505af11580156100cc573d6000803e3d6000fd5b50505050806001600160a01b0316866001600160a01b03167f8f487663f675208b5266b806b4c6b412dbb37cf38075b3291c9880665237ead9876040516101139190610489565b60405180910390a395945050505050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b038116610191576040516330be1a3d60e21b815260040160405180910390fd5b919050565b80356001600160a01b038116811461019157600080fd5b600080600080606085870312156101c357600080fd5b6101cc85610196565b9350602085013567ffffffffffffffff808211156101e957600080fd5b9086019060e082890312156101fd57600080fd5b9093506040860135908082111561021357600080fd5b818701915087601f83011261022757600080fd5b81358181111561023657600080fd5b88602082850101111561024857600080fd5b95989497505060200194505050565b6000808335601e1984360301811261026e57600080fd5b830160208101925035905067ffffffffffffffff81111561028e57600080fd5b8060051b36038213156102a057600080fd5b9250929050565b818352600060208085019450826000805b868110156102eb57823567ffffffffffffffff81168082146102d8578384fd5b89525096830196918301916001016102b8565b50959695505050505050565b6000808335601e1984360301811261030e57600080fd5b830160208101925035905067ffffffffffffffff81111561032e57600080fd5b8036038213156102a057600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b600060e083016001600160a01b038061037e85610196565b168552602061038f81860186610257565b60e088840152938490529260009061010088015b818310156103ca57846103b587610196565b168152948301946001929092019183016103a3565b6103d660408901610196565b6001600160a01b03811660408b015295506103f360608901610196565b6001600160a01b03811660608b01529550608088013560808a015261041b60a0890189610257565b9650945088810360a08a01526104328187876102a7565b9550505050505061044660c08401846102f7565b85830360c087015261045983828461033d565b9695505050505050565b6040815260006104766040830186610366565b828103602084015261045981858761033d565b60208152600061049c6020830184610366565b939250505056fea2646970667358221220c10ae674d7d6903936c4e3a45d6e7ab93b2a487080f3b631da53c602c668a76764736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80633938e38c14610030575b600080fd5b61004361003e3660046101ad565b61005f565b6040516001600160a01b03909116815260200160405180910390f35b60008061006b86610124565b60405163ab21f50760e01b81529091506001600160a01b0382169063ab21f5079061009e90889088908890600401610463565b600060405180830381600087803b1580156100b857600080fd5b505af11580156100cc573d6000803e3d6000fd5b50505050806001600160a01b0316866001600160a01b03167f8f487663f675208b5266b806b4c6b412dbb37cf38075b3291c9880665237ead9876040516101139190610489565b60405180910390a395945050505050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b038116610191576040516330be1a3d60e21b815260040160405180910390fd5b919050565b80356001600160a01b038116811461019157600080fd5b600080600080606085870312156101c357600080fd5b6101cc85610196565b9350602085013567ffffffffffffffff808211156101e957600080fd5b9086019060e082890312156101fd57600080fd5b9093506040860135908082111561021357600080fd5b818701915087601f83011261022757600080fd5b81358181111561023657600080fd5b88602082850101111561024857600080fd5b95989497505060200194505050565b6000808335601e1984360301811261026e57600080fd5b830160208101925035905067ffffffffffffffff81111561028e57600080fd5b8060051b36038213156102a057600080fd5b9250929050565b818352600060208085019450826000805b868110156102eb57823567ffffffffffffffff81168082146102d8578384fd5b89525096830196918301916001016102b8565b50959695505050505050565b6000808335601e1984360301811261030e57600080fd5b830160208101925035905067ffffffffffffffff81111561032e57600080fd5b8036038213156102a057600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b600060e083016001600160a01b038061037e85610196565b168552602061038f81860186610257565b60e088840152938490529260009061010088015b818310156103ca57846103b587610196565b168152948301946001929092019183016103a3565b6103d660408901610196565b6001600160a01b03811660408b015295506103f360608901610196565b6001600160a01b03811660608b01529550608088013560808a015261041b60a0890189610257565b9650945088810360a08a01526104328187876102a7565b9550505050505061044660c08401846102f7565b85830360c087015261045983828461033d565b9695505050505050565b6040815260006104766040830186610366565b828103602084015261045981858761033d565b60208152600061049c6020830184610366565b939250505056fea2646970667358221220c10ae674d7d6903936c4e3a45d6e7ab93b2a487080f3b631da53c602c668a76764736f6c63430008140033",
  "devdoc": {
    "errors": {
      "ERC1167FailedCreateClone()": [
        {
          "details": "A clone instance deployment failed."
        }
      ]
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}